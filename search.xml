<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Markdown 基础]]></title>
    <url>%2Falongswebsite%2F2019%2F07%2F05%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 基础Markdown语法常用分类标题 一级标题二级标题一级标题二级标题三级标题四级标题五级标题六级标题 12345678910一级标题===二级标题---# 一级标题 ## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车） 区块引用 区块引用 嵌套引用 三层嵌套引用 四层嵌套引用 …以此类推 12345&gt; 区块引用&gt;&gt; 嵌套引用&gt;&gt;&gt; 三层嵌套引用&gt;&gt;&gt;&gt; 四层嵌套引用&gt;&gt;&gt;&gt;&gt; ...以此类推 代码区块 每行缩进tab void print(int value) { print(&quot;%d&quot;, value); } &lt;pre&gt;&lt;code&gt;标签 void print(int value) { print("%d", value); } ```指定语言``` 123void print(int value) &#123; print("%d", value);&#125; 12345678910111213141516 void print(int value) &#123; print(&quot;%d&quot;, value); &#125;&lt;pre&gt;&lt;code&gt;void print(int value) &#123; print(&quot;%d&quot;, value);&#125;&lt;/code&gt;&lt;/pre&gt;```cvoid print(int value) &#123; print(&quot;%d&quot;, value);&#125; 强调斜体斜体粗体粗体 1234*斜体*_斜体_ **粗体**__粗体__ 列表 使用 * 、 + 和 - 任一符号标记 第一项 第二项 第三项 第四项 第五项 12345* 第一项+ 第二项- 第三项* 第四项+ 第五项 分割线 123***---_____ 链接Googlehttps://www.google.com 12[Google](https://www.google.com) &lt;https://www.google.com&gt; 图片 1![GitHub](https://github.com/fluidicon.png) 反斜杠相当于反转义作用。使符号成为普通符号。-–*a* 12\--- \*a* 符号标记 1`标记` 表格 代码块支持高亮的语言 language key 1C 1c ActionScript actionscript Apache apache AppleScript applescript AsciiDoc asciidoc AspectJ asciidoc AutoHotkey autohotkey AVR Assembler avrasm Axapta axapta Bash bash BrainFuck brainfuck Cap’n Proto capnproto Clojure REPL clojure Clojure clojure CMake cmake CoffeeScript coffeescript C++ cpp C# cs CSS css D d Dart d Delphi delphi Diff diff Django django DOS.bat dos Dust dust Elixir elixir ERB(Embedded Ruby) erb Erlang REPL erlang-repl Erlang erlang FIX fix F# fsharp G-code(ISO 6983) gcode Gherkin gherkin GLSL glsl Go go Gradle gradle Groovy groovy Haml haml Handlebars handlebars Haskell haskell Haxe haxe HTML html HTTP http Ini file ini Java java JavaScript javascript JSON json Lasso lasso Less less Lisp lisp LiveCode livecodeserver LiveScript livescript Lua lua Makefile makefile Markdown markdown Mathematica mathematica Matlab matlab MEL (Maya Embedded Language) mel Mercury mercury Mizar mizar Monkey monkey Nginx nginx Nimrod nimrod Nix nix NSIS nsis Objective C objectivec OCaml ocaml Oxygene oxygene Parser 3 parser3 Perl perl PHP php PowerShell powershell Processing processing Python’s profiler output profile Protocol Buffers protobuf Puppet puppet Python python Q q R r RenderMan RIB rib Roboconf roboconf RenderMan RSL rsl Ruby ruby Oracle Rules Language ruleslanguage Rust rust Scala scala Scheme scheme Scilab scilab SCSS scss Smali smali SmallTalk smalltalk SML sml SQL sql Stata stata STEP Part21(ISO 10303-21) step21 Stylus stylus Swift swift Tcl tcl Tex tex text text/plain Thrift thrift Twig twig TypeScript typescript Vala vala VB.NET vbnet VBScript in HTML vbscript-html VBScript vbscript Verilog verilog VHDL vhdl Vim Script vim Intel x86 Assembly x86asm XL xl XML xml YAML yml]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSLog 简介]]></title>
    <url>%2Falongswebsite%2F2019%2F07%2F04%2Fnslog%2F</url>
    <content type="text"><![CDATA[12345#ifdef DEBUG # define DLog(fmt, ...) NSLog((@"[文件名:%s]\n" "[函数名:%s]\n" "[行号:%d] \n" fmt), __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__); #else # define DLog(...); #endif __VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的”,”去掉的作用,否则会编译出错, 你可以试试。 __FILE__ 宏在预编译时会替换成当前的源文件名 __LINE__宏在预编译时会替换成当前的行号 __FUNCTION__宏在预编译时会替换成当前的函数名称有了以上这几个宏，特别是有了__VA_ARGS__ ，调试信息的输出就变得灵活多了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSLog</tag>
        <tag>控制台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const static extern 简介]]></title>
    <url>%2Falongswebsite%2F2019%2F07%2F04%2Fconst_static_extern%2F</url>
    <content type="text"><![CDATA[const与宏的区别： const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。 编译时刻:宏是预编译（编译之前处理），const是编译阶段。 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 宏的好处:宏能定义一些函数，方法。 const不能。 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。 注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。 12345678910111213141516171819// 常见的常量：抽成宏#define XMGAccount @"account"#define XMGUserDefault [NSUserDefaults standardUserDefaults]// 字符串常量static NSString * const account = @"account";- (void)viewDidLoad &#123; [super viewDidLoad]; // 偏好设置存储 // 使用宏 [XMGUserDefault setValue:@"123" forKey:XMGAccount]; // 使用const常量 [[NSUserDefaults standardUserDefaults] setValue:@"123" forKey:account];&#125; const作用：限制类型 const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p） 被const修饰的变量是只读的。 const 的基本使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)viewDidLoad &#123; [super viewDidLoad]; // 定义变量 int a = 1; // 允许修改值 a = 20; // const两种用法 // const:修饰基本变量p // 这两种写法是一样的，const只修饰右边的基本变量b const int b = 20; // b:只读变量 int const b = 20; // b:只读变量 // 不允许修改值 b = 1; // const:修饰指针变量*p，带*的变量，就是指针变量. // 定义一个指向int类型的指针变量，指向a的地址 int *p = &amp;a; int c = 10; p = &amp;c; // 允许修改p指向的地址， // 允许修改p访问内存空间的值 *p = 20; // const修饰指针变量访问的内存空间，修饰的是右边*p1， // 两种方式一样 const int *p1; // *p1：常量 p1:变量 int const *p1; // *p1：常量 p1:变量 // const修饰指针变量p1 int * const p1; // *p1:变量 p1:常量 // 第一个const修饰*p1 第二个const修饰 p1 // 两种方式一样 const int * const p1; // *p1：常量 p1：常量 int const * const p1; // *p1：常量 p1：常量&#125; const开发中使用场景： 当一个方法参数只读 定义只读全局变量 12345678910111213141516171819202122@implementation ViewController// 定义只读全局常量NSString * const str = @"123";// 当一个方法的参数，只读.- (void)test:(NSString * const)name&#123;&#125;// 指针只读,不能通过指针修改值- (void)test1:(int const *)a&#123;// *a = 10;&#125;// 基本数据类型只读- (void)test2:(int const)a&#123;&#125;@end static和extern简单使用 static作用 修饰局部变量： 延长局部变量的生命周期,程序结束才会销毁。 局部变量只会生成一份内存,只会初始化一次。 修饰全局变量 只能在本文件中访问,修改全局变量的作用域,生命周期不会改 extern作用: 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 extern工作原理: 先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 12345678910111213141516171819202122232425// 全局变量：只有一份内存，所有文件共享，与extern联合使用。int a = 20;// static修饰全局变量static int age = 20;- (void)test&#123; // static修饰局部变量 static int age = 0; age++; NSLog(@"%d",age);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self test]; [self test]; extern int age; NSLog(@"%d",age);&#125; static与cosnt联合使用 static与const作用:声明一个只读的静态变量 开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合 123456789101112131415161718192021// 开发中常用static修饰全局变量,只改变作用域// 为什么要改变全局变量作用域，防止重复声明全局变量。// 开发中声明的全局变量，有些不希望外界改动，只允许读取。// 比如一个基本数据类型不希望别人改动// 声明一个静态的全局只读常量static const int a = 20;// staic和const联合的作用:声明一个静态的全局只读常量// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。static NSString * const key = @"name";// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。static NSString const *key1 = @"name"; extern与const联合使用 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。 原因: static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合:只需要定义一份全局变量，多个文件共享。 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。 123456GlobeConst.h/*******************************首页****************************/extern NSString * const nameKey = @"name";/*******************************首页****************************/ 123456789GlobeConst.m#import &lt;Foundation/Foundation.h&gt;/*******************************首页****************************/NSString * const nameKey = @"name";/*******************************首页****************************/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>static</tag>
        <tag>const</tag>
        <tag>extern</tag>
      </tags>
  </entry>
</search>
